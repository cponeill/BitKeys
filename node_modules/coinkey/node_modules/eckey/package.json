{
  "name": "eckey",
  "version": "0.4.2",
  "description": "Elliptical curve cryptography for crypto currencies such as Litecoin and Bitcoin",
  "keywords": [
    "cryptography",
    "crypto",
    "bitcoin",
    "litecoin",
    "elliptical",
    "curve",
    "digital",
    "sign",
    "signing"
  ],
  "devDependencies": {
    "mocha": "1.*",
    "terst": "~0.1.0",
    "binstring": "~0.2.0",
    "secure-random": "~0.2.0",
    "mochify": "~0.4.2"
  },
  "repository": {
    "url": "https://github.com/cryptocoinjs/eckey",
    "type": "git"
  },
  "main": "./lib/eckey.js",
  "dependencies": {
    "ecurve": "~0.3.0",
    "ecurve-names": "~0.3.0",
    "bigi": "0.2.x"
  },
  "readme": "eckey\n=====\n\nJavaScript component for Elliptical curve cryptography for crypto currencies such as Bitcoin, Litecoin, Dogecoin, etc.\n\n\nWhy?\n----\n\nThis module provides a convenient way to compute relevant crypto currency operations that adhere to elliptical curve cryptography. To\nreally understand how private keys, public keys, addresses, and how elliptical curve cryptography works with JavaScript, read this: http://procbits.com/2013/08/27/generating-a-bitcoin-address-with-javascript\n\n\nInstallation\n------------\n\n    npm install --save eckey\n\n\nUsage\n-----\n\n### API\n\n#### ECKey([bytes], [compressed])\n\nConstructor function.\n\n- **bytes**: The private key bytes. Must be 32 bytes in length. Should be an `Array`, `Uint8Array`, or a `Buffer`.\n- **compressed**: Specify whether the key should be compressed or not.\n\n```js\nvar ECKey = require('eckey');\nvar secureRandom = require('secure-random'); \n\nvar bytes = secureRandom(32); //https://github.com/jprichardson/secure-random\nvar key1 = new ECKey(bytes);\nvar key2 = ECKey(bytes); //<--- can also use without \"new\"\nvar compressedKey = new ECKey(bytes, true);\n```\n\nNote: Previous versions of this module would generate a random array of bytes for you if you didn't pass as input any to the constructor. This behavior has been removed to remove complexity and to ensure that the random generation is done securely. In the past, it wasn't.\n\n\n#### compressed\n\nGet/set whether the point on the curve is compressed. Affects the output of the WIF (wallet import format) and the address.\n\n\n#### privateKey\n\nGet/set the private key. When setting, the type can be either an `Array`, `Buffer`, or `Uint8Array`. When getting, the type is always `Buffer`. Setting would be useful if you don't pass a private key to the constructor.\n\n```js\nvar ECKey = require('eckey');\nvar conv = require('binstring');\n\nvar privateKeyHex = \"1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\";\n\nvar key = new ECKey(conv(privateKeyHex, {in: 'hex', out: 'buffer'}), false);\nconsole.log(key.privatekey.toString('hex')); // => 1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\n\nvar keyCompressed = ECKey(conv(privateKeyHex, {in: 'hex', out: 'buffer'}), true);\n\n//nothing changes when compressed\nconsole.log(key.privatekey.toString('hex')); // => 1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\n```\n\n\n#### privateExportKey\n\nGet the private key along with a byte for compression if `compressed` is true. i.e.\n\n    if compressed\n      privateExportKey = privateKey + 0x01\n    else\n      privateExportKey = privateKey\n\nThis is useful inconjunction with the package [coinstring](https://github.com/cryptocoinjs/coinstring) to generate\n[Wallet Import Format](https://en.bitcoin.it/wiki/Wallet_import_format) keys.\n\n```js\nvar ECKey = require('eckey');\nvar conv = require('binstring');\n\nvar privateKeyHex = \"1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\";\n\nvar key = new ECKey(conv(privateKeyHex, {in: 'hex', out: 'buffer'}), false);\nconsole.log(key.privateExportKey.toString('hex')); // => 1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\n\nvar keyCompressed = new ECKey(conv(privateKeyHex, {in: 'hex', out: 'buffer'}), true);\n\n//notice the extra \"01\" at the end?\nconsole.log(key.privateExportKey.toString('hex')); // => 1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd01\n```\n\n\n#### publicKey\n\nGet the public key. The type is `Buffer`.\n\n```js\nvar ECKey = require('eckey');\nvar conv = require('binstring');\n\nvar privateKeyHex = \"1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\";\n\nvar key = new ECKey(conv(privateKeyHex, {in: 'hex', out: 'buffer'}), false);\nconsole.log(key.publickey.toString('hex')); \n// => 04d0988bfa799f7d7ef9ab3de97ef481cd0f75d2367ad456607647edde665d6f6fbdd594388756a7beaf73b4822bc22d36e9bda7db82df2b8b623673eefc0b7495\n\nvar keyCompressed = ECKey(conv(privateKeyHex, {in: 'hex', out: 'buffer'}), true);\n\nconsole.log(key.publickey.toString('hex')); \n// => 03d0988bfa799f7d7ef9ab3de97ef481cd0f75d2367ad456607647edde665d6f6f\n```\n\n\n\n#### publicPoint\n\nGet the [Public Key Point](https://github.com/cryptocoinjs/ecurve/blob/master/lib/ecurve.js) on the Ellipitical Curve. \n\n\n#### toString()\n\nReturns the string representation of the private key.\n\n```js\nvar ECKey = require('eckey');\nvar conv = require('binstring');\n\nvar privateKeyHex = \"1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\";\nvar key = new ECKey(conv(privateKeyHex, {in: 'hex', out: 'buffer'}), true);\n\nconsole.log(key.toString()) // => 1184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd\n```\n\n\n\nReferences\n----------\n- http://procbits.com/2013/08/27/generating-a-bitcoin-address-with-javascript\n- https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/src/eckey.js\n- https://github.com/vbuterin/bitcoinjs-lib/blob/master/src/eckey.js\n\n\n\n\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/cryptocoinjs/eckey/issues"
  },
  "homepage": "https://github.com/cryptocoinjs/eckey",
  "_id": "eckey@0.4.2",
  "_shasum": "cea53b7d529e42168f2c8597a7e8d32bc9e39436",
  "_from": "eckey@~0.4.0",
  "_resolved": "https://registry.npmjs.org/eckey/-/eckey-0.4.2.tgz"
}
